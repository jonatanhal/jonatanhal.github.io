---
layout: post
title:  "Cracking a weak checksum"
---
# The internet is a great place, good people. Good times.
I recently ran into a [challenge](http://wiremask.eu/reverse-challenge-weak-checksum/)
on the internet, and me being all new and naive about how hard it can be;
I felt the need to at least try to solve the challenge. What could possibly go wrong?

I don't have any previous experience with doing crackme's, so we'll see how it goes.

I tend to over-think things. I look for & suspect that the person who wrote up a challenge
would want to confuse me, I will try to not let this influence my attempts & assume that this
person doesn't wanna play anymore games than what's provided in the binary.

The Scenario, provided along with a binary from the link above; is laid out as follows:

>The IT team of a secret organization was asked to create a very fast
>and unbreakable hashing function that can store the checksum on 4
>bytes only.  The next day the algorithm was finished and implemented
>in all the authentication systems of the secret organization.
>
>You have been tasked by a competing organization to find a vulnerability
>within the authentication system.  One of their spy successfully
>extracted one of their binaries.
>
>...
>
>The goal of the challenge is to authenticate without modifying the binary.

Sounds reasonable!

## What are we dealing with?
~~~
$ file checksum-challenge.exe
checksum-challenge.exe: PE32 executable (console) Intel 80386, for MS Windows

$ sha1sum checksum-challenge.exe 
e9b0fb3d7ff45e02bd202009a75e40558bea8fce  checksum-challenge.exe
~~~
Let's try firing the program up using wine, I'm not sure that me using wine changes
anything, but I'm gonna assume that it's fine. The program seems to be working as it should.

~~~
wine checksum-challenge.exe 
Secret Panel v13.37
Password: dickhead
Wrong password.
~~~

It was worth a shot.

- - - 

# IDA-n't know what I'm doing

![Rare footage of author using IDA]({{ site-url }}/assets/weak_checksum_dog.jpg)

Let's fire up IDA & have a look. IDA finishes analyzing the executable
and, we are faced by a not so unfamiliar view, compared to when we ran
the program. Much because of the comments generated by IDA.

![IDA-view]({{site-url}}/assets/weak_checksum_ida001.png)
We see the strings & from
what I can make out, we are basically shoving the users input into the
esi-register and calling function referred to as `unk_402120`.

It's nice and handy to be able to see the printf, and scanf being
called, having a small amount of experience working with code that
uses those functions (I have written & compiled a C-program once,
so... yeah).  The exact meaning of the assembly is beyond my punitive
understanding of x86 assembly (or rather, assembly in general) but I
think it's safe to say that execution of the pictured assembly-code
goes something like this.

+ Move some data onto the stack, stick some data into registers 
+ Call the checksum-function, compare eax to the constant 4
+ Make a jump to a location, if the last functions return is greater
  or equal to what's in `loc_0402070`

It also looks like the string entered by the user is stored in `unk_401047`.

## Shooting virtualized fish in a bucket of water, using a emulated pistol.

Using wine to run my free edition of IDA, I was able to run
checksum-challenge.exe & *somehow* get a `Good Password` from the
executable. However, this involved manually correcting a out-of-bounds 
jump-instruction that were throwing an exception in IDA.  That
along with my inherently nonsensical approach, brought on by feelings
of frustration; makes me disqualify myself in this case, as I'm most likely
not able to reproduce it.

I had some issues with being able to input things into the program while debugging it.

When I tried debugging the executable using IDA, I tried running the
executable using wine in one terminal, at which point I switched over
to the running IDA-instance & attached to the running process. At this
point, the execution is paused, so I want to set a breakpoint around
the call to `sub_402120`, allowing me to enter the password & continue
execution.

After trying, trying & trying some more, I was able to successfully insert
a test-passphrase into the program.

Using breakpoints around `push offset aS`, I was able to step
through execution, until the `password:`-prompt appeared in the terminal I used
to start IDA. I entered a password & continued execution. Yay!

**With the IO working, let's continue & try to figure out what the hell is going on.**

## Function analysis

![Yep, it's a function!]({{site-url}}/assets/weak_checksum_wood.jpg)

### `sub_401210`
{% highlight nasm %}
sub_402120 proc near
push    ebp             ; push the base-pointer onto the stack
mov     ebp, esp        ; move the stack-pointer into the base-pointer
mov     ecx, 0FFFFFFFFh ; move the constant 0xFFFFFFFF into ecx
xor     eax, eax        ; clear eax
mov     edi, esi        ; move what's in esi into edi
cld                     ; Clear the direction-flag
repne scasb             ; loop over a string, looking for NUL
not     ecx             ; invert ecx
dec     ecx             ; decrement ecx by 1
mov     eax, ecx        ; move ecx into eax
pop     ebp             ; increment the stack-pointer
retn
sub_402120 endp
{% endhighlight %}

While googling for what the `repne scasb` instruction is doing, I came across
this wonderfully crafted explanation.

>The x86 family of microprocessors come with with the scasb
>instruction which searches for the first occurrence of a byte whose
>value is equal to that of the AL register  
>...  
>When used along with
>the `repne` prefix, the `scasb` instruction goes up (or down,
>depending on the direction flag) the memory, looking for the match.

[source](http://www.int80h.org/strlen/)

**But what part of the assembly-code is actually being looped upon?**  But
what is the instruction `repne scasb` doing?  Is it telling the CPU to
loop over the following instructions (similarly to how a `for`-loop in C
would start a block that will be iterated upon) or is it simply telling
the CPU to start from the top of the function?

The loop direction is in fact determined by the state of a flag, which
we see is set just before the `repne scasb` instruction. In this case,
since it's cleared, the direction is infact up.

Taking a look before the `repne scasb`, we see that the function is
shoving the **s**ource **i**ndex into the **d**estination **i**ndex.
I read this as we are simply shifting the reader forward in the string.

Stepping through the function's execution & seeing what it returns, it
seems the only thing it does is return the length of the entered
string, which gets put into eax.

So we can test this by debugging the program in IDA, with a breakpoint
set on `push offset aS`, entering a certain number of characters, and
see if the length of the entered strings corresponds to the
eax-register when `sub_401210` returns.

~~~
Secret Panel v13.37
Password: dickhead
Wrong password.
~~~

Looking at eax after `sub_401210` returned, it's set to 8. Good so far.

~~~
Secret Panel v13.37
Password: foobar
Wrong password.
~~~

Looking at eax after `sub_401210` returned, it's set to 6. Boom goes the dynamite.

So at this point it's safe to assume that the function `sub_401210` is
really something like C's strlen, which in and of itself isn't much
of a checksum for any password.  It's just strlen.

- - - 

## `loc_402070` aka. Probably the actual checksum-algo
So the program is checking if the length of the input is longer than 4. Interesting!

If we do enter some string longer than 4, the program jumps to another block, referenced
as `loc_402070`, which *probably* is the actual checksum-algorithm.

Here's the function as it's represented in IDA.
![IDA view of loc_402070]({{site-url}}/assets/weak_checksum_ida002.png)

Let's insert some comments & try get a grasp on what's going on.

{% highlight nasm %}
loc_402070:
xor     ebx, ebx                     ; clear ebx
mov     esi, offset unk_401047       ; move the input into esi
mov     ecx, dword_40103B            ; ???
shr     ecx, 2                       ; shift bits in ecx to the right by 2
call    sub_40210D                   ; sub_40210D, eax becomes ???
; ...
{% endhighlight %}

`loc_402070` makes a function call to `sub_40210D`, which looks like
this after I added some comments.

{% highlight nasm %}
sub_40210D proc near
push    ebp       ; push the base-pointers value onto the stack
mov     ebp, esp  ; move stack-pointers value into the base-pointer
push    esi       ; push the contents of esi onto the stack
xor     eax, eax  ; clear eax
cld               ; clear direction-flag
	
	; indented for readability.
	loc_402114: 
	; lodsd basically loads 4 characters of the string into ebx
	; at the same time, incrementing esi to point at the following
	; 4 bytes of the input.
	lodsd
	; In the first iteration, eax is 0
	add     ebx, eax
	; rotate the bits of the 4 bytes to the left by 1
	rol     ebx, 1
	; If esi is pointing to a value of 0, meaning that the full
	; string has been read, the loop breaks.
	loop    loc_402114  ; loop back to loc_402114

; When the loop breaks, ebx contains the mangled input
mov     eax, ebx  ; move value of ebx into eax
; During debugging the following instruction made esi point to the
; first letter of the inputted string.
pop     esi       ; pop 4 bytes from the stack into esi
; the base-pointer is pointing to what I'm suspecting is the target checksum
; located in 0x33fe48.
pop     ebp       ; pop 4 bytes from the stack into ebp
retn              ; return
sub_40210D endpp
{% endhighlight %}

Looking at `loc_402114`, the instruction `lodsd` loads 2 bytes of a
string from esi into eax. Then, depending on if the direction-flag is
cleared or set, increments or decrements esi by 2 respectively. In
this case, since we know from `sub_40210D` that the direction-flag is
cleared, it would make sense that esi would grow as the function loops
over the string.

{% highlight nasm %}
; Continued loc_402070
mov     dword_40103F, eax            ; move ??? into 
mov     eax, dword_40103F            ; move ??? into eax
mov     ebx, dword_401037            ; ebx is changed in sub_40210D
xor     eax, ebx                     ; xor eax & ebx
; ...
{% endhighlight %}

Code above 

{% highlight nasm %}
; Continued loc_402070
; The following instruction throws an exception in IDA, since it basically
; tries to make eax reference memory that is not available, WTF?

mov     dword ptr [eax], 0C3C9C031h
; ??? *
pop     large dword ptr fs:0
; add 0x24 to the stack-pointer
add     esp, 24h
; ...
{% endhighlight %}
**Windows-specific thing, not sure.* [^1]

**Is this some sort of anti-debugging thing?**

It's not like the program crashes when it's ran normally. This made me
believe that there was something wrong with how i opened the file in
IDA, and if i just opened the file correctly, IDA would generate
assembly that would make more sense.  Not sure if that in itself makes
any sense though.

Wierd.

So with this hurdle in place, I can't really debug the file
successfully anymore (thus greatly reducing my abilities to understand
what's going on), since the execution is stopped by the exception.
This makes me sad.

But I do however have the assembly in front of me, so I can try just
wrap my head around WTF is going on, without IDA's niceties.

{% highlight nasm %}
; Continued loc_402070
push    eax                          ; push eax onto the stack
rol     ebx, 4                       ; rotate ebx to the left by 4
shl     ebx, 1                       ; shift ebx to the left by 1
mov     eax, ebx                     ; move ebx into eax
mov     edi, offset unk_401057       ; move what's in unk_401057 into edi
mov     ecx, 4                       ; move 4 into ecx
cld                                  ; clear direction-flag
rep stosd

sub     edi, 10h                     ; subtract 10 from edi
xor     dword ptr [edi], 1C1E6AD9h   ; xor 4 bytes of edi's pointer & 0x1c1e6ad9
xor     dword ptr [edi+4], 0B1075BEh ; xor 4 bytes of (edi + 4)'s pointer & 0xb1075be
{% endhighlight %}

I would try and explain what I think is going on with the code above,
but I think the only thing I would succeed with is confusing myself &
my (potential) reader.

*Queue the fail trombone-thing*

- - -

# Lost in a lost world
Brute-forcing the password would be *as simple* as randomly selecting
passwords & shoving them down the throat of the executable until we get a
OK.

That feels like cheating, so at this point I'm hopeful that there is a
more natural way for me to interact with the executable, since my attempts at
using IDA resulted in a lot of headaches, but a small amount of success.

## So what did I learn?

**Assembly is hard**, and I have a rough time wrapping my head around
what's going where, who's doing who & how to computer. Using a debugger
I am at least able to visualize what's going on, but reading raw assembly;

Kudos to those who actually work with assembly & crack things, gods knows
I don't know how to.

I might revisit this challenge some day, but for now, I feel like I've
hit a brick wall. This was brought on not only by the brakes to my debugging
but also to my grave lack of understanding in regards to assembly,
debugging made it somewhat more easy to understand & occasionally go
"I predict that thing X will do Y to thing Z", and actually be somewhat
correct, sometimes.

- - -

#Shout-outs
+ [wiremask](http://wiremask.eu)
+ [G. Adam Stanislav's helpful piece on string-length](http://www.int80h.org/strlen/)
+ [Angolinux - 80386 Programmer's Reference Manual](http://www.fermimn.gov.it/linux/quarta/x86/)
+ Train-wrecks
+ Failed projects

#Footnotes
[^1]: [Information regarding the fs:0 instruction](https://en.wikipedia.org/wiki/Win32_Thread_Information_Block)
[^2]: [Regarding the REP-instructions](http://www.fermimn.gov.it/linux/quarta/x86/rep.htm)


